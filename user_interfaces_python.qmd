---
title: "User Interfaces (UIs) in Python"
subtitle: "CLI, TUI, and Web UIs in Python"
author: "Juan Imbet"
institute: "Master 2 (203) Financial Markets - Paris Dauphine - PSL University"
format:
  revealjs:
    theme: white
    css: src/assets/styles.css
    slide-number: true
    chalkboard: true
    preview-links: auto
    footer: "User Interfaces (UIs) in Python"
execute:
  enabled: false
date: "2025-10-23"
---


# User Interfaces (UIs) in Python

- Learn modern CLI tooling: `Click`, `Typer`, `Fire`, `docopt`


## Agenda for the day
- CLI fundamentals: args, parsing, structure, packaging
- Enhancing UX: colors, progress bars, animations, logs
- Framework deep dives: `Click`, `Typer`, `Fire`, `docopt`
- Web UIs: `Flask` (micro web), `Streamlit` (data apps)



---

## Where to find runnable examples
- `argparse` CLI: `src/cli-argparse/app.py` (subcommands: `run`, `info`)
- `Click` CLI: `src/cli-click/app.py` (group, `-v` flags, prompts)
- `Typer` CLI: `src/cli-typer/app.py` (callback, `run`, `greet`, `info`)
- `Fire` CLI: `src/cli-fire/app.py` (class → CLI)
- `docopt` CLI: `src/cli-docopt/app.py` (`--fast` mode demo)
- `Typer` + `Rich` CLI: `src/cli-typer-rich/app.py` (+ `sample.csv`)
- `Rich` demo: `src/rich-demo/app.py` (`yfinance`, metrics table)
- `tqdm` demo: `src/tqdm-demo/app.py` (basic + manual)
- `Flask` app: `src/flask-app/app.py` (form → landing)
- `Streamlit` app: `src/streamlit-app/app.py` (widgets + chart)

---

## Python UI landscape
- CLI (command-line) for automation, DevOps, data workflows
- TUI/terminal apps with color, layout, progress, tables
- Web UIs for end users: `Flask` (routes/templates), `Streamlit` (widgets)
- Component libraries: `Rich` for terminal visuals, `tqdm` for progress
- Choosing the right tool depends on users, runtime, and distribution

---

## CLI vs GUI vs Web: when to choose
- CLI: repeatable tasks, scripting (automation), integration, headless servers (servers without a GUI)
- GUI/Web: interactive exploration, broader audience, onboarding
- Cost: CLIs are fast to build; Other alternatives require hosting the application somewhere (e.g., web server) or deployment (installers).
- A CLI can complement a GUI/Web app for power users.

---

## Running Python scripts: standard args

- When you run a python script, we usually wrap the main logic in a `main()` function and call it under the `if __name__ == "__main__":` guard. This ensures that the script can be imported as a module without executing the main logic immediately.

```python
import sys
def main() -> int:
    # Main logic here
    return 0

if __name__ == "__main__":
    sys.exit(main())
```

- The `sys.exit(main())` call ensures that the script exits with the return code from `main()`, which is useful for signaling success or failure to the operating system.
- You can call the script in the terminal as 

```bash
python file.py
```



---

## Running Python scripts: standard args

- If your script accepts command-line arguments, you can access them via the `sys.argv` list. The first element is the script name, and subsequent elements are the arguments passed.

- `python file.py arg1 arg2`: args appear in `sys.argv`
- Use `argparse` for flags, types, help, defaults, validation
 - Prefer explicit options (e.g., `--input`, `--verbose`) over positionals ( keyword arguments are preferable for clarity)
 - Support `--version` and `--help` for discoverability
 - Exit codes: 0 success; non-zero for errors (e.g., `sys.exit(2)`)


---

## Main Objects in argparse

- ArgumentParser: The main entry point for argument parsing.
- Subparsers: Allow for subcommands (e.g., `run`, `info`).
- Arguments: Define the expected command-line arguments and their properties.

```python
# From src/cli-argparse/app.py
import argparse

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="argcli", description="Argparse demo")
    sub = parser.add_subparsers(dest="cmd", required=True) # this command enables subcommands, cmd (the command name) will hold the selected subcommand

    p_run = sub.add_parser("run", help="Run a computation")
    p_run.add_argument("--limit", type=int, default=5, help="Number of items")

    p_info = sub.add_parser("info", help="Show info")
    p_info.add_argument("--json", action="store_true", help="Output JSON")
    return parser
```


---

## argparse essentials (stdlib)

```python
# From src/cli-argparse/app.py
import argparse, json, sys

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="argcli", description="Argparse demo")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_run = sub.add_parser("run", help="Run a computation")
    p_run.add_argument("--limit", type=int, default=5, help="Number of items")

    p_info = sub.add_parser("info", help="Show info")
    p_info.add_argument("--json", action="store_true", help="Output JSON")
    return parser

def cmd_run(limit: int) -> int:
    for i in range(limit):
        print(f"processing {i}")
    return 0

def cmd_info(as_json: bool) -> int:
    data = {"python": sys.version.split()[0], "argv": sys.argv[1:]}
    print(json.dumps(data) if as_json else data)
    return 0

def main() -> int:
    args = build_parser().parse_args()
    if args.cmd == "run":
        return cmd_run(args.limit)
    if args.cmd == "info":
        return cmd_info(args.json)
    return 2
```


---

## Building user-friendly command-line tools

- Keep commands predictable: use the same simple shape every time
- Make help easy to understand: include short examples and show defaults
- Use friendly errors with clear next steps; offer a --verbose mode
 - Use friendly errors with clear next steps; offer a `--verbose` mode
- Start with sensible defaults; let people change them with options or a small config file
- Be open about update checks or data collection; make it opt-in and easy to turn off


---

## Colors, styles, and layout in terminal

- Use `Rich` for colors, markup, tables, panels, trees
- Prefer semantic styles over hard-coded ANSI (ANSI codes tie you to specific colors)
- Keep contrast and accessibility in mind
 - Minimal color in CI; allow `--no-color` flag
- Test rendering width and fallback for narrow terminals

```python
from rich.console import Console
from rich.panel import Panel
Console().print(Panel.fit("[bold cyan]Hello[/] [green]World![/]"))
```

Some colors

- [bold cyan]Hello[/]
- [green]World![/]
- [bold magenta]Rich[/]
- [bold yellow]Yellow[/]

---

## Animations and spinners 

- Show activity for slow steps (network, IO, compute)
- Use transient spinners that disappear on success
- Keep logs readable; avoid over-animated noise
 - Provide `--quiet` and `--verbose` modes for control

```python
from rich.spinner import Spinner
from rich.live import Live
from time import sleep
spinner = Spinner("dots", text="Working…")
with Live(spinner, transient=True):
    sleep(1.0)
```
---

## Progress bars with tqdm: intro
 - Wrap any iterable to visualize progress: `tqdm(range(...))`
- Auto ETA and rate; minimal code changes
- Works with lists, files, generators, `pandas`, `requests`
- Use total= for custom iterables or manual updates
- Nest with `position=` to avoid overlap

```python
# From src/tqdm-demo/app.py
from time import sleep
from tqdm import tqdm

# Basic iteration
for i in tqdm(range(200), desc="Loop"):
    sleep(0.005)
```

---

## tqdm: advanced patterns

- Manual mode: `bar.update(n)` with `bar.refresh()`
- File iteration: `tqdm(open("big.csv"))` with `desc="Loading"`
 - Pandas: `df.progress_apply(...)`; enable via `tqdm.pandas()`
- Nested loops: `position=0/1` and `leave=False` for cleanup
- Logging compatibility: use `tqdm.write` for clean lines

```python
# From src/tqdm-demo/app.py (manual mode)
from time import sleep
from tqdm import tqdm as tq
with tq(total=50, desc="Manual") as bar:
    for _ in range(10):
        sleep(0.02)
        bar.update(5)
```
---

## Rich: terminal UI toolkit (pretty terminal output)
- Pretty print, markup, syntax-highlighted code
- Tables, panels, trees, progress, live dashboards
- Logging handler integrates with stdlib logging
- Tracebacks with code context and hyperlinks
- Works cross-platform; excellent docs and examples

```python
from rich.table import Table
from rich.console import Console

console = Console()
table = Table(title="Results")
for col in ("id", "score", "status"):
    table.add_column(col, justify="right")
for i in range(3):
    table.add_row(str(i), f"{0.9 - i*0.1:.2f}", "ok")
console.print(table)
```

---

## Rich progress and live updates
- Compose multiple progress bars with columns
- `transient=True` to clear bars after completion
- Update `rich.Panel` content during long tasks
- Integrate with async: `rich.progress` with tasks
- Keep output deterministic in CI

```python
# From src/rich-demo/app.py (table snippet)
from rich.table import Table
from rich.console import Console

tbl = Table(title="Sample closing prices (last 5)")
tbl.add_column("Date"); tbl.add_column("Close", justify="right")
sample = [("2025-01-01", "100.23"), ("2025-01-02", "101.10")]
for d, c in sample:
    tbl.add_row(d, c)
Console().print(tbl)
```
---


## Click: overview (build commands with less code)

- Well-tested toolkit to build command-line apps
- Lets you define commands, options, and prompts in a readable way
- Auto-generates help pages and supports colors and environment variables
- Shares settings across commands so you don’t repeat yourself
- A good fit when your tool grows beyond a single command

---

## Click: basic commands and groups

```python
# From src/cli-click/app.py
import os, click

@click.group()
@click.version_option("0.1.0")
@click.option("--verbose", "-v", count=True, help="Increase verbosity")
@click.pass_context
def cli(ctx, verbose):
    ctx.obj = {"verbose": verbose, "api_key": os.getenv("DEMO_API_KEY", "")}

@cli.command()
@click.option("--limit", default=5, show_default=True, type=int)
@click.option("--verbose", "-v", count=True, help="Increase verbosity")
@click.pass_context
def run(ctx, limit, verbose):
    eff_v = (ctx.obj.get("verbose", 0) or 0) + (verbose or 0)
    if eff_v:
        click.echo(f"[v{eff_v}] api_key set? {bool(ctx.obj['api_key'])}")
    for i in range(limit):
        click.echo(f"click: {i}")

@cli.command()
@click.option("--name", prompt=True)
@click.option("--verbose", "-v", count=True, help="Increase verbosity")
@click.pass_context
def greet(ctx, name, verbose):
    eff_v = (ctx.obj.get("verbose", 0) or 0) + (verbose or 0)
    if eff_v:
        click.echo(f"[v{eff_v}] Greeting user…")
    click.secho(f"Hello {name}", fg="green", bold=True)

if __name__ == "__main__":
    cli()
```

---

## Click: options, prompts, and types (plain English)
- Types: `INT`, `FLOAT`, `PATH`, `Choice`, custom types
- Prompts: `click.prompt` for interactive input
- Confirmation: `click.confirm` with `abort=True`
- File and directory parameters with path types
- Callbacks and validation hooks for robust UX

```python
@click.command()
@click.option("--mode", type=click.Choice(["fast","safe"]))
@click.option("--file", type=click.Path(exists=True))
@click.option("--yes", is_flag=True, help="Assume yes")
def main(mode, file, yes):
    click.echo(f"mode={mode} file={file} yes={yes}")
```

---

## Click: command groups and config
- Group subcommands into logical namespaces
- Shared context via `@click.pass_context` or objects
- Read config from TOML/YAML and env vars
- Provide `--config` to override defaults
- Generate shell completion for bash/zsh/fish

```python
@click.group()
@click.option("--config", type=click.Path())
@click.pass_context
def cli(ctx, config):
    ctx.obj = {"config": config}
```
---

## Typer: overview (simple commands, clear types)

- Built on top of Click, but feels more “Pythonic” and concise
- Writes your help pages for you and suggests completions in the shell
- Easy to read and maintain; great editor support
- Works for small scripts and larger multi-command tools
- A friendly default choice for new CLI projects

---

## Typer: basic commands and structure

```python
# From src/cli-typer/app.py (summary)
from __future__ import annotations
import json, platform, time
from pathlib import Path
import typer

__version__ = "0.1.0"
app = typer.Typer(add_completion=True, no_args_is_help=True)

def _version_callback(value: bool):
    if value:
        typer.echo(__version__); raise typer.Exit()

@app.command()
def run(limit: int = 5, delay: float = 0.1, dry_run: bool = False):
    for i in range(limit):
        typer.echo(f"typer: {i}");
        if not dry_run and delay: time.sleep(delay)

@app.command()
def greet(name: str, times: int = 1, loud: bool = False):
    msg = f"Hello {name}"; [typer.echo(msg.upper() if loud else msg) for _ in range(times)]
```

---

## Typer: arguments, options, callbacks
- Positional args = parameters without defaults
- Options = parameters with default values
- Use annotations for types and validation
- Callbacks for pre-run configuration (e.g., logging)
- Autocompletion for choices and enums

```python
# From src/cli-typer/app.py (callback)
@app.callback()
def main(
    ctx: typer.Context,
    verbose: int = typer.Option(0, "--verbose", "-v", count=True, help="Increase verbosity (repeatable)"),
    config: Path | None = typer.Option(None, "--config", "-c", help="Path to a config file"),
    version: bool | None = typer.Option(None, "--version", callback=_version_callback, is_eager=True, help="Show version and exit"),
):
    ctx.ensure_object(dict)
    ctx.obj["verbose"] = verbose
    ctx.obj["config_path"] = str(config) if config else None
```

---

## Typer vs Click: when to choose
- Choose `Typer` if you like type hints and minimal boilerplate
- Choose `Click` for advanced context and ecosystem maturity
- Both generate help and completion; interop is easy
- Avoid mixing parsing libraries in one app
- Prefer consistency across your org/team

---

## Google Fire: instant CLIs
- Turn any Python object into a CLI automatically
- Perfect for prototypes and internal tools
- Minimal boilerplate; discover APIs quickly
- Not ideal for polished UX or complex help
- Compose with `argparse`/`Click` for advanced needs

```python
# From src/cli-fire/app.py
import fire

class Tools:
    def add(self, a: int, b: int) -> int:
        return a + b
    def greet(self, name: str = "World") -> str:
        return f"Hi {name}!"

if __name__ == "__main__":
    fire.Fire(Tools)
```
---


## docopt: parse from usage strings
- Define CLI contract via the usage docstring
- Parser derived from human-readable spec
- Elegant for simple, stable CLIs
- Less active project; fine for small tools
- Keep usage consistent with implementation

---

## docopt: usage-based parsing

```python
# From src/cli-docopt/app.py
"""
Usage:
    app.py run [--fast] [--times=N]
    app.py (-h | --help)
    app.py --version
"""
from docopt import docopt
from hashlib import sha256
import time

def main():
        args = docopt(__doc__, version="1.0.0")
        times = int(args["--times"]) if args["--times"] else 3
        fast = bool(args["--fast"])  # True if --fast provided
        def compute_digest(i: int, fast: bool) -> str:
                payload_len = 1_000 if fast else 8_000
                delay = 0.02 if fast else 0.12
                payload = ("x" * payload_len).encode()
                digest = sha256(payload).hexdigest()[:8]
                time.sleep(delay)
                return digest
        for i in range(times):
                digest = compute_digest(i, fast)
                print(f"iter={i} fast={fast} digest={digest}")
```

---

## Packaging CLIs for users

- Use `pyproject.toml` (PEP 621) to declare project metadata, dependencies, and console scripts
    - PEP = Python Enhancement Proposal (a public design note); 621 defines how to write project info
- `pipx` runs Python CLIs in isolated environments and adds them to your `PATH` (great for end users)
- Provide Homebrew or standalone binaries if you target macOS or machines without Python
- Version with SemVer (semantic versioning: `MAJOR.MINOR.PATCH`), changelog, and minimal pinning for stability
- Document install, upgrade, and uninstall steps clearly

---

## Fire: instant CLIs

```python
# From src/cli-fire/app.py
import fire

class Tools:
    """Google Fire example: exposes methods as CLI commands"""
    def add(self, a: int, b: int) -> int:
        return a + b
    def greet(self, name: str = "World") -> str:
        return f"Hi {name}!"

if __name__ == "__main__":
    fire.Fire(Tools)
```

- Declares metadata (name, version), dependencies, and build backend
- Replaces setup.py/setup.cfg for most modern packages
 - Defines console scripts under `[project.scripts]` for CLI entry points
- Supported by build tools like Hatchling, PDM, Poetry, and Setuptools

---

## What is pipx?
- A helper that installs Python command-line apps in their own sandbox
- Each app gets its own environment so tools don’t fight over versions
- Great for end users: keeps your system Python clean and stable
- Usage: `pipx install mytool` · `pipx upgrade mytool` · `pipx uninstall mytool`
- Works alongside `pip`/`conda` (those manage libraries inside your projects)

---

## Example: Typer + Rich mini app (1/3)

- Goal: CSV summary with pretty table and progress
- CLI: input path, delimiter option, verbose flag
- Rich table for output; progress during parsing
- Errors → non-zero exit and friendly message
- Structure ready for packaging as a script

---

## Example: Typer + Rich mini app (1/3)

```python
import csv, typer
from rich.table import Table
from rich.console import Console
from rich.progress import track

app = typer.Typer()
console = Console()
```

---

## Example: Typer + Rich mini app (2/3)

 - Read rows with `track(...)` for progress bar
- Count rows and distinct values
- Render a Rich table of summary stats
- Handle FileNotFoundError cleanly
- Return exit code via raise typer.Exit(code)

```python
@app.command()
def summarize(path: str, delim: str = ","):
    """Summarize a CSV file: number of rows and show first row."""
    try:
        rows = list(track(csv.DictReader(open(path), delimiter=delim), description="Reading"))
    except FileNotFoundError:
        console.print("[red]File not found[/]")
        raise typer.Exit(code=2)
    table = Table(title="Summary")
    table.add_column("rows")
    table.add_column("columns")
    n_rows = len(rows)
    n_cols = len(rows[0].keys()) if rows else 0
    table.add_row(str(n_rows), str(n_cols))
    console.print(table)
    if rows:
        console.rule("First Row")
        t2 = Table(*rows[0].keys(), title="Row 0")
        t2.add_row(*[str(v) for v in rows[0].values()])
        console.print(t2)
```
---

## Example: Typer + Rich mini app (3/3)
 - Add `--version` and `--verbose` flags
 - Package with entry point in `pyproject.toml`
- Test with pytest and Typer CliRunner
- Document examples in README with copy-paste
 - Ship via `pipx` for easy install

```python
if __name__ == "__main__":
    app()
```
---

## Flask: micro web framework

- Routing with decorators: GET/POST endpoints
- Jinja templates for HTML rendering
- Request handling, forms, sessions, cookies
- JSON APIs with jsonify; blueprints for structure
- Ideal for small to medium services

---

## Flask: basic routes and request handling


```python
# From src/flask-app/app.py
from flask import Flask, render_template, request, redirect, url_for
app = Flask(__name__)

@app.get("/")
def home():
    form = {"name": request.args.get("name", ""), "email": request.args.get("email", ""),
            "role": request.args.get("role", ""), "bio": request.args.get("bio", ""),
            "subscribe": request.args.get("subscribe", "") == "on"}
    return render_template("index.html", title="Profile Form", form=form, error=None)

@app.post("/submit")
def submit():
    name = request.form.get("name", "").strip()
    if not name:
        form = dict(request.form); form["subscribe"] = bool(request.form.get("subscribe"))
        return render_template("index.html", title="Profile Form", form=form, error="Name is required"), 400
    return redirect(url_for("welcome", **request.form))

@app.get("/welcome")
def welcome():
    data = {k: request.args.get(k, "") for k in ("name","email","role","bio")}
    data["subscribe"] = request.args.get("subscribe") == "on"
    return render_template("welcome.html", title="Welcome", **data)
```

---

## Flask: templates and forms (web pages with placeholders)
- Templates are HTML files where you insert values (e.g., a user name)
- Keep a base page (`layout.html`) and fill named blocks to reuse structure
- Handle forms by reading fields from the request (or use helper libraries)
- Static files (CSS, images) live under a folder called `static/`
- App settings (like secret keys) go in `app.config`

```html
<!-- From src/flask-app/templates/index.html -->
{% extends "layout.html" %}
{% block body %}
    <h1>{{ title }}</h1>
    {% if error %}<div class="alert alert-danger">{{ error }}</div>{% endif %}
    <form method="post" action="{{ url_for('submit') }}">
        <label><strong>Name*</strong></label>
        <input type="text" name="name" value="{{ form.name or '' }}">
        <label><strong>Email</strong></label>
        <input type="email" name="email" value="{{ form.email or '' }}">
        <button type="submit">Submit</button>
    </form>
{% endblock %}
```

---

## Flask: testing and CLI integration
- Flask test client for unit/integration tests
- Blueprints for modular routes and reuse
- Integrate Click commands via Flask CLI
- Config for dev/prod/testing via env vars
- Deploy with gunicorn/uvicorn behind a reverse proxy

```python
from flask.testing import FlaskClient
client: FlaskClient = app.test_client()
resp = client.get("/")
```
---

## Streamlit: data app framework
- Rapid app dev with Python-only scripts
- Widgets: `slider`, `selectbox`, `text_input`, `file_uploader`
- Live re-execution on interaction
- Built-in layout, media, charts, and caching
- Great for demos, prototyping, and internal tools

```python
# From src/streamlit-app/app.py
import streamlit as st
import pandas as pd
import numpy as np

st.set_page_config(page_title="Streamlit Demo", layout="centered")
st.title("Streamlit UI Demo")
name = st.text_input("Name", value="World")
if st.button("Greet"):
    st.success(f"Hello {name}")

st.subheader("Random Chart")
st.line_chart(pd.DataFrame(np.random.randn(30, 3), columns=list("ABC")))
```

---

## Streamlit: layout, state, caching (how the page remembers things)
- Arrange columns with `st.columns` and `st.sidebar`
- Use `st.session_state` for state across runs
- Cache data with `st.cache_data` and functions with `st.cache_resource`
- File uploader for CSV/Excel ingestion
- Use `st.experimental_rerun` for flow control when needed

```python
left, right = st.columns(2)
with left: st.metric("Score", 95)
```

---

## Streamlit: charts and data
- `st.line_chart`, `st.bar_chart` for quick plots
- Use Altair, Plotly, or Matplotlib components
- Dataframe display with `st.dataframe` and styling
- Interactive filters connected to charts
- Performance: prefer vectorized ops and caching

```python
import pandas as pd, numpy as np
st.line_chart(pd.DataFrame(np.random.randn(30, 3)))
```

---

## VS Code/Codespaces for UI dev
- Install `Python`, `Pylance`, `Jupyter`, and `Streamlit` extensions
- Integrated terminal and debugger for CLIs and `Flask`
- Launch configs for `app.py` and `streamlit run`
- Tasks to lint, test, and package CLIs
- Dev containers/Codespaces replicate environments reliably

---

## Debugging CLIs and web apps
- CLI: use `argparse`/`Typer` to surface parameters
 - Logging levels with `--verbose` for diagnosis
- Set breakpoints; inspect variables in VS Code debugger
 - Flask debug with `FLASK_DEBUG=1` (dev only)
 - Streamlit `config.toml` to tweak server and caching

---

## Testing CLIs effectively
- Use `pytest` and `CliRunner` (`Typer`/`Click`) for invocations
- Golden output tests for help and common paths
- Mock IO, network, and time for determinism
- Validate exit codes and error messages
- Keep fixtures small and fast for tight feedback

```python
from typer.testing import CliRunner
runner = CliRunner()
result = runner.invoke(app, ["--help"])
assert result.exit_code == 0
```

---

## Structure for maintainable CLIs
- `src/` layout with package `__init__.py` and modules
- `commands/` for subcommands; `utils/` for helpers
- `config/` for defaults; `logging/` setup; `tests/`
 - `pyproject.toml` with scripts and pinned deps
- CI workflow to lint, test, and build

---

## Logging and observability
- Use stdlib logging with `Rich` handler for color
- Structured logs for machine parsing (JSON if needed)
- Separate user messages (stdout) from logs (stderr)
- Tracebacks pretty-printed with `rich.traceback`
- Include correlation IDs for multi-process flows

---

## Distribution and updates
 - `pipx` recommended for end-user CLIs
- Homebrew formula for macOS users (optional)
- Single-file zipapp or PyInstaller for no-Python hosts
- Self-update commands with signature checks
- Signed releases and SBOMs for security-conscious orgs

---

## Security considerations
- Validate and sanitize user input in CLIs and web
- Avoid printing secrets; redaction in logs
- Use .env files carefully; prefer env vars or vaults
- Keep dependencies updated; pin and scan for CVEs
- Rate-limit and CSRF protect `Flask` endpoints

---

## Accessibility and UX
 - Provide `--help` examples and readable error text
 - Color contrast; support `--no-color` for accessibility
- Keyboard-only workflows for terminal/TUI
- ARIA and semantics in Flask templates
- `Streamlit`: consider font size and mobile layout

---

## Performance tips
- Avoid per-item prints; batch and log smartly
- Use `tqdm` only when the loop is sufficiently long
- `Rich` live updates with minimal refresh rate
- Cache heavy computations (`Streamlit`/`Flask` layer)
- Profile hotspots with cProfile and line_profiler

---

## Putting it together: choosing wisely
- Start with a CLI; add `Streamlit` for wider audience
- For services/APIs, prefer `Flask` with proper structure
- Use `Typer` + `Rich` for developer-facing tools
 - Keep setup simple: `pyproject.toml` + `pipx`
- Document examples and provide templates

---

## Resources and official docs
- `Rich`: https://rich.readthedocs.io
- `tqdm`: https://tqdm.github.io
- `Click`: https://click.palletsprojects.com
- `Typer`: https://typer.tiangolo.com
- `Flask`: https://flask.palletsprojects.com
- `Streamlit`: https://docs.streamlit.io

---

## Wrap-up and next steps
- You can extend CLI to TUI with Textual (Rich-based)
- Add auth and persistence to Flask apps
- Deploy Streamlit to Streamlit Cloud or container
- Set up CI templates for CLI and web projects
- Share feedback and propose topics for next session
